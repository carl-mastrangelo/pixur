// Code generated by protoc-gen-pxrtab; DO NOT EDIT.

package tables

import (
	"context"
	"log"
	"runtime"

	"github.com/golang/protobuf/proto"

	"pixur.org/pixur/be/schema/db"

	schema "pixur.org/pixur/be/schema"

	model "pixur.org/pixur/be/schema/db/model"
)

var (
	_ = schema.Pic{}

	_ = model.TableOptions{}
)

var SqlTables = map[string][]string{

	"cockroach": {

		"CREATE TABLE \"Pics\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"index_order\" bigint NOT NULL, " +

			"\"score_order\" integer NOT NULL, " +

			"\"sched_order\" integer NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE INDEX \"PicsIndexOrder\" ON \"Pics\" (\"index_order\",\"id\");",

		"CREATE INDEX \"PicsScoreOrder\" ON \"Pics\" (\"score_order\",\"id\");",

		"CREATE INDEX \"PicsSchedOrder\" ON \"Pics\" (\"sched_order\",\"id\");",

		"CREATE TABLE \"Tags\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"name\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"name\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"PicTags\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"tag_id\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"tag_id\")" +

			");",

		"CREATE TABLE \"PicIdents\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"type\" integer NOT NULL, " +

			"\"value\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"type\",\"value\")" +

			");",

		"CREATE INDEX \"PicIdentsIdent\" ON \"PicIdents\" (\"type\",\"value\");",

		"CREATE TABLE \"PicComments\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"comment_id\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"comment_id\"), " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\")" +

			");",

		"CREATE TABLE \"PicVotes\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"user_id\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"user_id\",\"pic_id\",\"index\"), " +

			"PRIMARY KEY(\"pic_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"PicCommentVotes\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"comment_id\" bigint NOT NULL, " +

			"\"user_id\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"Users\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"ident\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"ident\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"UserEvents\" (" +

			"\"user_id\" bigint NOT NULL, " +

			"\"created_ts\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"user_id\",\"created_ts\",\"index\")" +

			");",

		"CREATE TABLE \"CustomData\" (" +

			"\"key_type\" bigint NOT NULL, " +

			"\"key1\" bigint NOT NULL, " +

			"\"key2\" bigint NOT NULL, " +

			"\"key3\" bigint NOT NULL, " +

			"\"key4\" bigint NOT NULL, " +

			"\"key5\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"key_type\",\"key1\",\"key2\",\"key3\",\"key4\",\"key5\")" +

			");",

		"CREATE TABLE \"_SequenceTable\" (\"the_sequence\" bigint NOT NULL);",
	},

	"mysql": {

		"CREATE TABLE `Pics` (" +

			"`id` bigint(20) NOT NULL, " +

			"`index_order` bigint(20) NOT NULL, " +

			"`score_order` int NOT NULL, " +

			"`sched_order` int NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`id`)" +

			");",

		"CREATE INDEX `PicsIndexOrder` ON `Pics` (`index_order`,`id`);",

		"CREATE INDEX `PicsScoreOrder` ON `Pics` (`score_order`,`id`);",

		"CREATE INDEX `PicsSchedOrder` ON `Pics` (`sched_order`,`id`);",

		"CREATE TABLE `Tags` (" +

			"`id` bigint(20) NOT NULL, " +

			"`name` blob NOT NULL, " +

			"`data` blob NOT NULL, " +

			"UNIQUE(`name`(255)), " +

			"PRIMARY KEY(`id`)" +

			");",

		"CREATE TABLE `PicTags` (" +

			"`pic_id` bigint(20) NOT NULL, " +

			"`tag_id` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`pic_id`,`tag_id`)" +

			");",

		"CREATE TABLE `PicIdents` (" +

			"`pic_id` bigint(20) NOT NULL, " +

			"`type` int NOT NULL, " +

			"`value` blob NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`pic_id`,`type`,`value`(255))" +

			");",

		"CREATE INDEX `PicIdentsIdent` ON `PicIdents` (`type`,`value`(255));",

		"CREATE TABLE `PicComments` (" +

			"`pic_id` bigint(20) NOT NULL, " +

			"`comment_id` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"UNIQUE(`comment_id`), " +

			"PRIMARY KEY(`pic_id`,`comment_id`)" +

			");",

		"CREATE TABLE `PicVotes` (" +

			"`pic_id` bigint(20) NOT NULL, " +

			"`user_id` bigint(20) NOT NULL, " +

			"`index` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"UNIQUE(`user_id`,`pic_id`,`index`), " +

			"PRIMARY KEY(`pic_id`,`user_id`,`index`)" +

			");",

		"CREATE TABLE `PicCommentVotes` (" +

			"`pic_id` bigint(20) NOT NULL, " +

			"`comment_id` bigint(20) NOT NULL, " +

			"`user_id` bigint(20) NOT NULL, " +

			"`index` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`pic_id`,`comment_id`,`user_id`,`index`)" +

			");",

		"CREATE TABLE `Users` (" +

			"`id` bigint(20) NOT NULL, " +

			"`ident` blob NOT NULL, " +

			"`data` blob NOT NULL, " +

			"UNIQUE(`ident`(255)), " +

			"PRIMARY KEY(`id`)" +

			");",

		"CREATE TABLE `UserEvents` (" +

			"`user_id` bigint(20) NOT NULL, " +

			"`created_ts` bigint(20) NOT NULL, " +

			"`index` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`user_id`,`created_ts`,`index`)" +

			");",

		"CREATE TABLE `CustomData` (" +

			"`key_type` bigint(20) NOT NULL, " +

			"`key1` bigint(20) NOT NULL, " +

			"`key2` bigint(20) NOT NULL, " +

			"`key3` bigint(20) NOT NULL, " +

			"`key4` bigint(20) NOT NULL, " +

			"`key5` bigint(20) NOT NULL, " +

			"`data` blob NOT NULL, " +

			"PRIMARY KEY(`key_type`,`key1`,`key2`,`key3`,`key4`,`key5`)" +

			");",

		"CREATE TABLE `_SequenceTable` (`the_sequence` bigint(20) NOT NULL);",
	},

	"postgres": {

		"CREATE TABLE \"Pics\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"index_order\" bigint NOT NULL, " +

			"\"score_order\" integer NOT NULL, " +

			"\"sched_order\" integer NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE INDEX \"PicsIndexOrder\" ON \"Pics\" (\"index_order\",\"id\");",

		"CREATE INDEX \"PicsScoreOrder\" ON \"Pics\" (\"score_order\",\"id\");",

		"CREATE INDEX \"PicsSchedOrder\" ON \"Pics\" (\"sched_order\",\"id\");",

		"CREATE TABLE \"Tags\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"name\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"name\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"PicTags\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"tag_id\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"tag_id\")" +

			");",

		"CREATE TABLE \"PicIdents\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"type\" integer NOT NULL, " +

			"\"value\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"type\",\"value\")" +

			");",

		"CREATE INDEX \"PicIdentsIdent\" ON \"PicIdents\" (\"type\",\"value\");",

		"CREATE TABLE \"PicComments\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"comment_id\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"comment_id\"), " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\")" +

			");",

		"CREATE TABLE \"PicVotes\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"user_id\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"user_id\",\"pic_id\",\"index\"), " +

			"PRIMARY KEY(\"pic_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"PicCommentVotes\" (" +

			"\"pic_id\" bigint NOT NULL, " +

			"\"comment_id\" bigint NOT NULL, " +

			"\"user_id\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"Users\" (" +

			"\"id\" bigint NOT NULL, " +

			"\"ident\" bytea NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"UNIQUE(\"ident\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"UserEvents\" (" +

			"\"user_id\" bigint NOT NULL, " +

			"\"created_ts\" bigint NOT NULL, " +

			"\"index\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"user_id\",\"created_ts\",\"index\")" +

			");",

		"CREATE TABLE \"CustomData\" (" +

			"\"key_type\" bigint NOT NULL, " +

			"\"key1\" bigint NOT NULL, " +

			"\"key2\" bigint NOT NULL, " +

			"\"key3\" bigint NOT NULL, " +

			"\"key4\" bigint NOT NULL, " +

			"\"key5\" bigint NOT NULL, " +

			"\"data\" bytea NOT NULL, " +

			"PRIMARY KEY(\"key_type\",\"key1\",\"key2\",\"key3\",\"key4\",\"key5\")" +

			");",

		"CREATE TABLE \"_SequenceTable\" (\"the_sequence\" bigint NOT NULL);",
	},

	"sqlite3": {

		"CREATE TABLE \"Pics\" (" +

			"\"id\" integer NOT NULL, " +

			"\"index_order\" integer NOT NULL, " +

			"\"score_order\" integer NOT NULL, " +

			"\"sched_order\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE INDEX \"PicsIndexOrder\" ON \"Pics\" (\"index_order\",\"id\");",

		"CREATE INDEX \"PicsScoreOrder\" ON \"Pics\" (\"score_order\",\"id\");",

		"CREATE INDEX \"PicsSchedOrder\" ON \"Pics\" (\"sched_order\",\"id\");",

		"CREATE TABLE \"Tags\" (" +

			"\"id\" integer NOT NULL, " +

			"\"name\" blob NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"UNIQUE(\"name\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"PicTags\" (" +

			"\"pic_id\" integer NOT NULL, " +

			"\"tag_id\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"tag_id\")" +

			");",

		"CREATE TABLE \"PicIdents\" (" +

			"\"pic_id\" integer NOT NULL, " +

			"\"type\" integer NOT NULL, " +

			"\"value\" blob NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"type\",\"value\")" +

			");",

		"CREATE INDEX \"PicIdentsIdent\" ON \"PicIdents\" (\"type\",\"value\");",

		"CREATE TABLE \"PicComments\" (" +

			"\"pic_id\" integer NOT NULL, " +

			"\"comment_id\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"UNIQUE(\"comment_id\"), " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\")" +

			");",

		"CREATE TABLE \"PicVotes\" (" +

			"\"pic_id\" integer NOT NULL, " +

			"\"user_id\" integer NOT NULL, " +

			"\"index\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"UNIQUE(\"user_id\",\"pic_id\",\"index\"), " +

			"PRIMARY KEY(\"pic_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"PicCommentVotes\" (" +

			"\"pic_id\" integer NOT NULL, " +

			"\"comment_id\" integer NOT NULL, " +

			"\"user_id\" integer NOT NULL, " +

			"\"index\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"pic_id\",\"comment_id\",\"user_id\",\"index\")" +

			");",

		"CREATE TABLE \"Users\" (" +

			"\"id\" integer NOT NULL, " +

			"\"ident\" blob NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"UNIQUE(\"ident\"), " +

			"PRIMARY KEY(\"id\")" +

			");",

		"CREATE TABLE \"UserEvents\" (" +

			"\"user_id\" integer NOT NULL, " +

			"\"created_ts\" integer NOT NULL, " +

			"\"index\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"user_id\",\"created_ts\",\"index\")" +

			");",

		"CREATE TABLE \"CustomData\" (" +

			"\"key_type\" integer NOT NULL, " +

			"\"key1\" integer NOT NULL, " +

			"\"key2\" integer NOT NULL, " +

			"\"key3\" integer NOT NULL, " +

			"\"key4\" integer NOT NULL, " +

			"\"key5\" integer NOT NULL, " +

			"\"data\" blob NOT NULL, " +

			"PRIMARY KEY(\"key_type\",\"key1\",\"key2\",\"key3\",\"key4\",\"key5\")" +

			");",

		"CREATE TABLE \"_SequenceTable\" (\"the_sequence\" integer NOT NULL);",
	},
}

var SqlInitTables = map[string][]string{

	"cockroach": {
		"INSERT INTO \"_SequenceTable\" (\"the_sequence\") VALUES (1);",
	},

	"mysql": {
		"INSERT INTO `_SequenceTable` (`the_sequence`) VALUES (1);",
	},

	"postgres": {
		"INSERT INTO \"_SequenceTable\" (\"the_sequence\") VALUES (1);",
	},

	"sqlite3": {
		"INSERT INTO \"_SequenceTable\" (\"the_sequence\") VALUES (1);",
	},
}

type JobBeginner interface {
	db.Beginner
	db.DBAdaptable
}

func NewJob(ctx context.Context, beg JobBeginner) (*Job, error) {
	adap := beg.Adapter()
	var alloc *db.IdAlloc
	if all, ok := beg.(db.IdAllocatable); ok {
		alloc = all.IdAllocator()
		if err := db.PreallocateIds(ctx, beg, alloc, adap); err != nil {
			return nil, err
		}
	}
	tx, err := beg.Begin(ctx)
	if err != nil {
		return nil, err
	}
	j := &Job{
		ctx:   ctx,
		tx:    tx,
		alloc: alloc,
		adap:  adap,
	}
	runtime.SetFinalizer(j, jobCloser)
	return j, nil
}

type Job struct {
	ctx   context.Context
	tx    db.QuerierExecutorCommitter
	adap  db.DBAdapter
	alloc *db.IdAlloc
	done  bool
}

func (j *Job) Commit() error {
	defer runtime.SetFinalizer(j, nil)
	err := j.tx.Commit()
	if err == nil {
		j.done = true
	}
	return err
}

func (j *Job) Rollback() error {
	if j.done {
		return nil
	}
	j.done = true
	defer runtime.SetFinalizer(j, nil)
	return j.tx.Rollback()
}

var jobCloser = func(j *Job) {
	log.Println("warning: found orphaned job")
	if err := j.Rollback(); err != nil {
		log.Println("error rolling back orphaned job", err)
	}
}

func (j *Job) AllocId() (int64, error) {
	return db.AllocIdJob(j.ctx, j.tx, j.alloc, j.adap)
}

type PicsPrimary struct {
	Id *int64
}

func (_ PicsPrimary) Unique() {}

var _ db.UniqueIdx = PicsPrimary{}

var colsPicsPrimary = []string{"id"}

func (idx PicsPrimary) Cols() []string {
	return colsPicsPrimary
}

func (idx PicsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

type PicsIndexOrder struct {
	IndexOrder *int64

	Id *int64
}

var _ db.Idx = PicsIndexOrder{}

var colsPicsIndexOrder = []string{"index_order", "id"}

func (idx PicsIndexOrder) Cols() []string {
	return colsPicsIndexOrder
}

func (idx PicsIndexOrder) Vals() (vals []interface{}) {
	var done bool

	if idx.IndexOrder != nil {
		if done {
			panic("Extra value IndexOrder")
		}
		vals = append(vals, *idx.IndexOrder)
	} else {
		done = true
	}

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

type PicsScoreOrder struct {
	ScoreOrder *int32

	Id *int64
}

var _ db.Idx = PicsScoreOrder{}

var colsPicsScoreOrder = []string{"score_order", "id"}

func (idx PicsScoreOrder) Cols() []string {
	return colsPicsScoreOrder
}

func (idx PicsScoreOrder) Vals() (vals []interface{}) {
	var done bool

	if idx.ScoreOrder != nil {
		if done {
			panic("Extra value ScoreOrder")
		}
		vals = append(vals, *idx.ScoreOrder)
	} else {
		done = true
	}

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

type PicsSchedOrder struct {
	SchedOrder *int32

	Id *int64
}

var _ db.Idx = PicsSchedOrder{}

var colsPicsSchedOrder = []string{"sched_order", "id"}

func (idx PicsSchedOrder) Cols() []string {
	return colsPicsSchedOrder
}

func (idx PicsSchedOrder) Vals() (vals []interface{}) {
	var done bool

	if idx.SchedOrder != nil {
		if done {
			panic("Extra value SchedOrder")
		}
		vals = append(vals, *idx.SchedOrder)
	} else {
		done = true
	}

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

func KeyForPic(pb *schema.Pic) PicsPrimary {

	Id := pb.IdCol()

	return PicsPrimary{

		Id: &Id,
	}
}

var colsPics = []string{"id", "index_order", "score_order", "sched_order", "data"}

func (j *Job) ScanPics(opts db.Opts, cb func(*schema.Pic) error) error {
	return db.Scan(j.tx, "Pics", opts, func(data []byte) error {
		var pb schema.Pic
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPics(opts db.Opts) (rows []*schema.Pic, err error) {
	err = j.ScanPics(opts, func(data *schema.Pic) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ IdCol() int64 } = (*schema.Pic)(nil)

var _ interface{ IndexOrderCol() int64 } = (*schema.Pic)(nil)

var _ interface{ LowerScoreBound() int32 } = (*schema.Pic)(nil)

var _ interface{ UpperScoreBound() int32 } = (*schema.Pic)(nil)

func (j *Job) InsertPic(pb *schema.Pic) error {
	return j.InsertPicRow(&PicRow{
		Data: pb,

		Id: pb.IdCol(),

		IndexOrder: pb.IndexOrderCol(),

		ScoreOrder: pb.LowerScoreBound(),

		SchedOrder: pb.UpperScoreBound(),
	})
}

func (j *Job) InsertPicRow(row *PicRow) error {
	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.IndexOrder)

	vals = append(vals, row.ScoreOrder)

	vals = append(vals, row.SchedOrder)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "Pics", colsPics, vals, j.adap)
}

var _ interface{ IdCol() int64 } = (*schema.Pic)(nil)

var _ interface{ IndexOrderCol() int64 } = (*schema.Pic)(nil)

var _ interface{ LowerScoreBound() int32 } = (*schema.Pic)(nil)

var _ interface{ UpperScoreBound() int32 } = (*schema.Pic)(nil)

func (j *Job) UpdatePic(pb *schema.Pic) error {
	return j.UpdatePicRow(&PicRow{
		Data: pb,

		Id: pb.IdCol(),

		IndexOrder: pb.IndexOrderCol(),

		ScoreOrder: pb.LowerScoreBound(),

		SchedOrder: pb.UpperScoreBound(),
	})
}

func (j *Job) UpdatePicRow(row *PicRow) error {
	key := KeyForPic(row.Data)

	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.IndexOrder)

	vals = append(vals, row.ScoreOrder)

	vals = append(vals, row.SchedOrder)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "Pics", colsPics, vals, key, j.adap)
}

func (j *Job) DeletePic(key PicsPrimary) error {
	return db.Delete(j.tx, "Pics", key, j.adap)
}

type TagsPrimary struct {
	Id *int64
}

func (_ TagsPrimary) Unique() {}

var _ db.UniqueIdx = TagsPrimary{}

var colsTagsPrimary = []string{"id"}

func (idx TagsPrimary) Cols() []string {
	return colsTagsPrimary
}

func (idx TagsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

type TagsName struct {
	Name *string
}

func (_ TagsName) Unique() {}

var _ db.UniqueIdx = TagsName{}

var colsTagsName = []string{"name"}

func (idx TagsName) Cols() []string {
	return colsTagsName
}

func (idx TagsName) Vals() (vals []interface{}) {
	var done bool

	if idx.Name != nil {
		if done {
			panic("Extra value Name")
		}
		vals = append(vals, *idx.Name)
	} else {
		done = true
	}

	return
}

func KeyForTag(pb *schema.Tag) TagsPrimary {

	Id := pb.IdCol()

	return TagsPrimary{

		Id: &Id,
	}
}

var colsTags = []string{"id", "name", "data"}

func (j *Job) ScanTags(opts db.Opts, cb func(*schema.Tag) error) error {
	return db.Scan(j.tx, "Tags", opts, func(data []byte) error {
		var pb schema.Tag
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindTags(opts db.Opts) (rows []*schema.Tag, err error) {
	err = j.ScanTags(opts, func(data *schema.Tag) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ IdCol() int64 } = (*schema.Tag)(nil)

var _ interface{ NameCol() string } = (*schema.Tag)(nil)

func (j *Job) InsertTag(pb *schema.Tag) error {
	return j.InsertTagRow(&TagRow{
		Data: pb,

		Id: pb.IdCol(),

		Name: pb.NameCol(),
	})
}

func (j *Job) InsertTagRow(row *TagRow) error {
	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.Name)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "Tags", colsTags, vals, j.adap)
}

var _ interface{ IdCol() int64 } = (*schema.Tag)(nil)

var _ interface{ NameCol() string } = (*schema.Tag)(nil)

func (j *Job) UpdateTag(pb *schema.Tag) error {
	return j.UpdateTagRow(&TagRow{
		Data: pb,

		Id: pb.IdCol(),

		Name: pb.NameCol(),
	})
}

func (j *Job) UpdateTagRow(row *TagRow) error {
	key := KeyForTag(row.Data)

	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.Name)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "Tags", colsTags, vals, key, j.adap)
}

func (j *Job) DeleteTag(key TagsPrimary) error {
	return db.Delete(j.tx, "Tags", key, j.adap)
}

type PicTagsPrimary struct {
	PicId *int64

	TagId *int64
}

func (_ PicTagsPrimary) Unique() {}

var _ db.UniqueIdx = PicTagsPrimary{}

var colsPicTagsPrimary = []string{"pic_id", "tag_id"}

func (idx PicTagsPrimary) Cols() []string {
	return colsPicTagsPrimary
}

func (idx PicTagsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.TagId != nil {
		if done {
			panic("Extra value TagId")
		}
		vals = append(vals, *idx.TagId)
	} else {
		done = true
	}

	return
}

func KeyForPicTag(pb *schema.PicTag) PicTagsPrimary {

	PicId := pb.PicIdCol()

	TagId := pb.TagIdCol()

	return PicTagsPrimary{

		PicId: &PicId,

		TagId: &TagId,
	}
}

var colsPicTags = []string{"pic_id", "tag_id", "data"}

func (j *Job) ScanPicTags(opts db.Opts, cb func(*schema.PicTag) error) error {
	return db.Scan(j.tx, "PicTags", opts, func(data []byte) error {
		var pb schema.PicTag
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPicTags(opts db.Opts) (rows []*schema.PicTag, err error) {
	err = j.ScanPicTags(opts, func(data *schema.PicTag) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ PicIdCol() int64 } = (*schema.PicTag)(nil)

var _ interface{ TagIdCol() int64 } = (*schema.PicTag)(nil)

func (j *Job) InsertPicTag(pb *schema.PicTag) error {
	return j.InsertPicTagRow(&PicTagRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		TagId: pb.TagIdCol(),
	})
}

func (j *Job) InsertPicTagRow(row *PicTagRow) error {
	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.TagId)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "PicTags", colsPicTags, vals, j.adap)
}

var _ interface{ PicIdCol() int64 } = (*schema.PicTag)(nil)

var _ interface{ TagIdCol() int64 } = (*schema.PicTag)(nil)

func (j *Job) UpdatePicTag(pb *schema.PicTag) error {
	return j.UpdatePicTagRow(&PicTagRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		TagId: pb.TagIdCol(),
	})
}

func (j *Job) UpdatePicTagRow(row *PicTagRow) error {
	key := KeyForPicTag(row.Data)

	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.TagId)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "PicTags", colsPicTags, vals, key, j.adap)
}

func (j *Job) DeletePicTag(key PicTagsPrimary) error {
	return db.Delete(j.tx, "PicTags", key, j.adap)
}

type PicIdentsPrimary struct {
	PicId *int64

	Type *schema.PicIdent_Type

	Value *[]byte
}

func (_ PicIdentsPrimary) Unique() {}

var _ db.UniqueIdx = PicIdentsPrimary{}

var colsPicIdentsPrimary = []string{"pic_id", "type", "value"}

func (idx PicIdentsPrimary) Cols() []string {
	return colsPicIdentsPrimary
}

func (idx PicIdentsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.Type != nil {
		if done {
			panic("Extra value Type")
		}
		vals = append(vals, *idx.Type)
	} else {
		done = true
	}

	if idx.Value != nil {
		if done {
			panic("Extra value Value")
		}
		vals = append(vals, *idx.Value)
	} else {
		done = true
	}

	return
}

type PicIdentsIdent struct {
	Type *schema.PicIdent_Type

	Value *[]byte
}

var _ db.Idx = PicIdentsIdent{}

var colsPicIdentsIdent = []string{"type", "value"}

func (idx PicIdentsIdent) Cols() []string {
	return colsPicIdentsIdent
}

func (idx PicIdentsIdent) Vals() (vals []interface{}) {
	var done bool

	if idx.Type != nil {
		if done {
			panic("Extra value Type")
		}
		vals = append(vals, *idx.Type)
	} else {
		done = true
	}

	if idx.Value != nil {
		if done {
			panic("Extra value Value")
		}
		vals = append(vals, *idx.Value)
	} else {
		done = true
	}

	return
}

func KeyForPicIdent(pb *schema.PicIdent) PicIdentsPrimary {

	PicId := pb.PicIdCol()

	Type := pb.TypeCol()

	Value := pb.ValueCol()

	return PicIdentsPrimary{

		PicId: &PicId,

		Type: &Type,

		Value: &Value,
	}
}

var colsPicIdents = []string{"pic_id", "type", "value", "data"}

func (j *Job) ScanPicIdents(opts db.Opts, cb func(*schema.PicIdent) error) error {
	return db.Scan(j.tx, "PicIdents", opts, func(data []byte) error {
		var pb schema.PicIdent
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPicIdents(opts db.Opts) (rows []*schema.PicIdent, err error) {
	err = j.ScanPicIdents(opts, func(data *schema.PicIdent) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ PicIdCol() int64 } = (*schema.PicIdent)(nil)

var _ interface{ TypeCol() schema.PicIdent_Type } = (*schema.PicIdent)(nil)

var _ interface{ ValueCol() []byte } = (*schema.PicIdent)(nil)

func (j *Job) InsertPicIdent(pb *schema.PicIdent) error {
	return j.InsertPicIdentRow(&PicIdentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		Type: pb.TypeCol(),

		Value: pb.ValueCol(),
	})
}

func (j *Job) InsertPicIdentRow(row *PicIdentRow) error {
	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.Type)

	vals = append(vals, row.Value)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "PicIdents", colsPicIdents, vals, j.adap)
}

var _ interface{ PicIdCol() int64 } = (*schema.PicIdent)(nil)

var _ interface{ TypeCol() schema.PicIdent_Type } = (*schema.PicIdent)(nil)

var _ interface{ ValueCol() []byte } = (*schema.PicIdent)(nil)

func (j *Job) UpdatePicIdent(pb *schema.PicIdent) error {
	return j.UpdatePicIdentRow(&PicIdentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		Type: pb.TypeCol(),

		Value: pb.ValueCol(),
	})
}

func (j *Job) UpdatePicIdentRow(row *PicIdentRow) error {
	key := KeyForPicIdent(row.Data)

	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.Type)

	vals = append(vals, row.Value)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "PicIdents", colsPicIdents, vals, key, j.adap)
}

func (j *Job) DeletePicIdent(key PicIdentsPrimary) error {
	return db.Delete(j.tx, "PicIdents", key, j.adap)
}

type PicCommentsPrimary struct {
	PicId *int64

	CommentId *int64
}

func (_ PicCommentsPrimary) Unique() {}

var _ db.UniqueIdx = PicCommentsPrimary{}

var colsPicCommentsPrimary = []string{"pic_id", "comment_id"}

func (idx PicCommentsPrimary) Cols() []string {
	return colsPicCommentsPrimary
}

func (idx PicCommentsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.CommentId != nil {
		if done {
			panic("Extra value CommentId")
		}
		vals = append(vals, *idx.CommentId)
	} else {
		done = true
	}

	return
}

type PicCommentsCommentId struct {
	CommentId *int64
}

func (_ PicCommentsCommentId) Unique() {}

var _ db.UniqueIdx = PicCommentsCommentId{}

var colsPicCommentsCommentId = []string{"comment_id"}

func (idx PicCommentsCommentId) Cols() []string {
	return colsPicCommentsCommentId
}

func (idx PicCommentsCommentId) Vals() (vals []interface{}) {
	var done bool

	if idx.CommentId != nil {
		if done {
			panic("Extra value CommentId")
		}
		vals = append(vals, *idx.CommentId)
	} else {
		done = true
	}

	return
}

func KeyForPicComment(pb *schema.PicComment) PicCommentsPrimary {

	PicId := pb.PicIdCol()

	CommentId := pb.CommentIdCol()

	return PicCommentsPrimary{

		PicId: &PicId,

		CommentId: &CommentId,
	}
}

var colsPicComments = []string{"pic_id", "comment_id", "data"}

func (j *Job) ScanPicComments(opts db.Opts, cb func(*schema.PicComment) error) error {
	return db.Scan(j.tx, "PicComments", opts, func(data []byte) error {
		var pb schema.PicComment
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPicComments(opts db.Opts) (rows []*schema.PicComment, err error) {
	err = j.ScanPicComments(opts, func(data *schema.PicComment) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ PicIdCol() int64 } = (*schema.PicComment)(nil)

var _ interface{ CommentIdCol() int64 } = (*schema.PicComment)(nil)

func (j *Job) InsertPicComment(pb *schema.PicComment) error {
	return j.InsertPicCommentRow(&PicCommentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		CommentId: pb.CommentIdCol(),
	})
}

func (j *Job) InsertPicCommentRow(row *PicCommentRow) error {
	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.CommentId)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "PicComments", colsPicComments, vals, j.adap)
}

var _ interface{ PicIdCol() int64 } = (*schema.PicComment)(nil)

var _ interface{ CommentIdCol() int64 } = (*schema.PicComment)(nil)

func (j *Job) UpdatePicComment(pb *schema.PicComment) error {
	return j.UpdatePicCommentRow(&PicCommentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		CommentId: pb.CommentIdCol(),
	})
}

func (j *Job) UpdatePicCommentRow(row *PicCommentRow) error {
	key := KeyForPicComment(row.Data)

	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.CommentId)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "PicComments", colsPicComments, vals, key, j.adap)
}

func (j *Job) DeletePicComment(key PicCommentsPrimary) error {
	return db.Delete(j.tx, "PicComments", key, j.adap)
}

type PicVotesPrimary struct {
	PicId *int64

	UserId *int64

	Index *int64
}

func (_ PicVotesPrimary) Unique() {}

var _ db.UniqueIdx = PicVotesPrimary{}

var colsPicVotesPrimary = []string{"pic_id", "user_id", "index"}

func (idx PicVotesPrimary) Cols() []string {
	return colsPicVotesPrimary
}

func (idx PicVotesPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.UserId != nil {
		if done {
			panic("Extra value UserId")
		}
		vals = append(vals, *idx.UserId)
	} else {
		done = true
	}

	if idx.Index != nil {
		if done {
			panic("Extra value Index")
		}
		vals = append(vals, *idx.Index)
	} else {
		done = true
	}

	return
}

type PicVotesUserId struct {
	UserId *int64

	PicId *int64

	Index *int64
}

func (_ PicVotesUserId) Unique() {}

var _ db.UniqueIdx = PicVotesUserId{}

var colsPicVotesUserId = []string{"user_id", "pic_id", "index"}

func (idx PicVotesUserId) Cols() []string {
	return colsPicVotesUserId
}

func (idx PicVotesUserId) Vals() (vals []interface{}) {
	var done bool

	if idx.UserId != nil {
		if done {
			panic("Extra value UserId")
		}
		vals = append(vals, *idx.UserId)
	} else {
		done = true
	}

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.Index != nil {
		if done {
			panic("Extra value Index")
		}
		vals = append(vals, *idx.Index)
	} else {
		done = true
	}

	return
}

func KeyForPicVote(pb *schema.PicVote) PicVotesPrimary {

	PicId := pb.PicIdCol()

	UserId := pb.UserIdCol()

	Index := pb.IndexCol()

	return PicVotesPrimary{

		PicId: &PicId,

		UserId: &UserId,

		Index: &Index,
	}
}

var colsPicVotes = []string{"pic_id", "user_id", "index", "data"}

func (j *Job) ScanPicVotes(opts db.Opts, cb func(*schema.PicVote) error) error {
	return db.Scan(j.tx, "PicVotes", opts, func(data []byte) error {
		var pb schema.PicVote
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPicVotes(opts db.Opts) (rows []*schema.PicVote, err error) {
	err = j.ScanPicVotes(opts, func(data *schema.PicVote) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ PicIdCol() int64 } = (*schema.PicVote)(nil)

var _ interface{ UserIdCol() int64 } = (*schema.PicVote)(nil)

var _ interface{ IndexCol() int64 } = (*schema.PicVote)(nil)

func (j *Job) InsertPicVote(pb *schema.PicVote) error {
	return j.InsertPicVoteRow(&PicVoteRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		UserId: pb.UserIdCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) InsertPicVoteRow(row *PicVoteRow) error {
	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.UserId)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "PicVotes", colsPicVotes, vals, j.adap)
}

var _ interface{ PicIdCol() int64 } = (*schema.PicVote)(nil)

var _ interface{ UserIdCol() int64 } = (*schema.PicVote)(nil)

var _ interface{ IndexCol() int64 } = (*schema.PicVote)(nil)

func (j *Job) UpdatePicVote(pb *schema.PicVote) error {
	return j.UpdatePicVoteRow(&PicVoteRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		UserId: pb.UserIdCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) UpdatePicVoteRow(row *PicVoteRow) error {
	key := KeyForPicVote(row.Data)

	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.UserId)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "PicVotes", colsPicVotes, vals, key, j.adap)
}

func (j *Job) DeletePicVote(key PicVotesPrimary) error {
	return db.Delete(j.tx, "PicVotes", key, j.adap)
}

type PicCommentVotesPrimary struct {
	PicId *int64

	CommentId *int64

	UserId *int64

	Index *int64
}

func (_ PicCommentVotesPrimary) Unique() {}

var _ db.UniqueIdx = PicCommentVotesPrimary{}

var colsPicCommentVotesPrimary = []string{"pic_id", "comment_id", "user_id", "index"}

func (idx PicCommentVotesPrimary) Cols() []string {
	return colsPicCommentVotesPrimary
}

func (idx PicCommentVotesPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.PicId != nil {
		if done {
			panic("Extra value PicId")
		}
		vals = append(vals, *idx.PicId)
	} else {
		done = true
	}

	if idx.CommentId != nil {
		if done {
			panic("Extra value CommentId")
		}
		vals = append(vals, *idx.CommentId)
	} else {
		done = true
	}

	if idx.UserId != nil {
		if done {
			panic("Extra value UserId")
		}
		vals = append(vals, *idx.UserId)
	} else {
		done = true
	}

	if idx.Index != nil {
		if done {
			panic("Extra value Index")
		}
		vals = append(vals, *idx.Index)
	} else {
		done = true
	}

	return
}

func KeyForPicCommentVote(pb *schema.PicCommentVote) PicCommentVotesPrimary {

	PicId := pb.PicIdCol()

	CommentId := pb.CommentIdCol()

	UserId := pb.UserIdCol()

	Index := pb.IndexCol()

	return PicCommentVotesPrimary{

		PicId: &PicId,

		CommentId: &CommentId,

		UserId: &UserId,

		Index: &Index,
	}
}

var colsPicCommentVotes = []string{"pic_id", "comment_id", "user_id", "index", "data"}

func (j *Job) ScanPicCommentVotes(opts db.Opts, cb func(*schema.PicCommentVote) error) error {
	return db.Scan(j.tx, "PicCommentVotes", opts, func(data []byte) error {
		var pb schema.PicCommentVote
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindPicCommentVotes(opts db.Opts) (rows []*schema.PicCommentVote, err error) {
	err = j.ScanPicCommentVotes(opts, func(data *schema.PicCommentVote) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ PicIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ CommentIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ UserIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ IndexCol() int64 } = (*schema.PicCommentVote)(nil)

func (j *Job) InsertPicCommentVote(pb *schema.PicCommentVote) error {
	return j.InsertPicVoteCommentRow(&PicVoteCommentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		CommentId: pb.CommentIdCol(),

		UserId: pb.UserIdCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) InsertPicVoteCommentRow(row *PicVoteCommentRow) error {
	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.CommentId)

	vals = append(vals, row.UserId)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "PicCommentVotes", colsPicCommentVotes, vals, j.adap)
}

var _ interface{ PicIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ CommentIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ UserIdCol() int64 } = (*schema.PicCommentVote)(nil)

var _ interface{ IndexCol() int64 } = (*schema.PicCommentVote)(nil)

func (j *Job) UpdatePicCommentVote(pb *schema.PicCommentVote) error {
	return j.UpdatePicVoteCommentRow(&PicVoteCommentRow{
		Data: pb,

		PicId: pb.PicIdCol(),

		CommentId: pb.CommentIdCol(),

		UserId: pb.UserIdCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) UpdatePicVoteCommentRow(row *PicVoteCommentRow) error {
	key := KeyForPicCommentVote(row.Data)

	var vals []interface{}

	vals = append(vals, row.PicId)

	vals = append(vals, row.CommentId)

	vals = append(vals, row.UserId)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "PicCommentVotes", colsPicCommentVotes, vals, key, j.adap)
}

func (j *Job) DeletePicCommentVote(key PicCommentVotesPrimary) error {
	return db.Delete(j.tx, "PicCommentVotes", key, j.adap)
}

type UsersPrimary struct {
	Id *int64
}

func (_ UsersPrimary) Unique() {}

var _ db.UniqueIdx = UsersPrimary{}

var colsUsersPrimary = []string{"id"}

func (idx UsersPrimary) Cols() []string {
	return colsUsersPrimary
}

func (idx UsersPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.Id != nil {
		if done {
			panic("Extra value Id")
		}
		vals = append(vals, *idx.Id)
	} else {
		done = true
	}

	return
}

type UsersIdent struct {
	Ident *string
}

func (_ UsersIdent) Unique() {}

var _ db.UniqueIdx = UsersIdent{}

var colsUsersIdent = []string{"ident"}

func (idx UsersIdent) Cols() []string {
	return colsUsersIdent
}

func (idx UsersIdent) Vals() (vals []interface{}) {
	var done bool

	if idx.Ident != nil {
		if done {
			panic("Extra value Ident")
		}
		vals = append(vals, *idx.Ident)
	} else {
		done = true
	}

	return
}

func KeyForUser(pb *schema.User) UsersPrimary {

	Id := pb.IdCol()

	return UsersPrimary{

		Id: &Id,
	}
}

var colsUsers = []string{"id", "ident", "data"}

func (j *Job) ScanUsers(opts db.Opts, cb func(*schema.User) error) error {
	return db.Scan(j.tx, "Users", opts, func(data []byte) error {
		var pb schema.User
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindUsers(opts db.Opts) (rows []*schema.User, err error) {
	err = j.ScanUsers(opts, func(data *schema.User) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ IdCol() int64 } = (*schema.User)(nil)

var _ interface{ IdentCol() string } = (*schema.User)(nil)

func (j *Job) InsertUser(pb *schema.User) error {
	return j.InsertUserRow(&UserRow{
		Data: pb,

		Id: pb.IdCol(),

		Ident: pb.IdentCol(),
	})
}

func (j *Job) InsertUserRow(row *UserRow) error {
	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.Ident)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "Users", colsUsers, vals, j.adap)
}

var _ interface{ IdCol() int64 } = (*schema.User)(nil)

var _ interface{ IdentCol() string } = (*schema.User)(nil)

func (j *Job) UpdateUser(pb *schema.User) error {
	return j.UpdateUserRow(&UserRow{
		Data: pb,

		Id: pb.IdCol(),

		Ident: pb.IdentCol(),
	})
}

func (j *Job) UpdateUserRow(row *UserRow) error {
	key := KeyForUser(row.Data)

	var vals []interface{}

	vals = append(vals, row.Id)

	vals = append(vals, row.Ident)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "Users", colsUsers, vals, key, j.adap)
}

func (j *Job) DeleteUser(key UsersPrimary) error {
	return db.Delete(j.tx, "Users", key, j.adap)
}

type UserEventsPrimary struct {
	UserId *int64

	CreatedTs *int64

	Index *int64
}

func (_ UserEventsPrimary) Unique() {}

var _ db.UniqueIdx = UserEventsPrimary{}

var colsUserEventsPrimary = []string{"user_id", "created_ts", "index"}

func (idx UserEventsPrimary) Cols() []string {
	return colsUserEventsPrimary
}

func (idx UserEventsPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.UserId != nil {
		if done {
			panic("Extra value UserId")
		}
		vals = append(vals, *idx.UserId)
	} else {
		done = true
	}

	if idx.CreatedTs != nil {
		if done {
			panic("Extra value CreatedTs")
		}
		vals = append(vals, *idx.CreatedTs)
	} else {
		done = true
	}

	if idx.Index != nil {
		if done {
			panic("Extra value Index")
		}
		vals = append(vals, *idx.Index)
	} else {
		done = true
	}

	return
}

func KeyForUserEvent(pb *schema.UserEvent) UserEventsPrimary {

	UserId := pb.UserIdCol()

	CreatedTs := pb.CreatedTsCol()

	Index := pb.IndexCol()

	return UserEventsPrimary{

		UserId: &UserId,

		CreatedTs: &CreatedTs,

		Index: &Index,
	}
}

var colsUserEvents = []string{"user_id", "created_ts", "index", "data"}

func (j *Job) ScanUserEvents(opts db.Opts, cb func(*schema.UserEvent) error) error {
	return db.Scan(j.tx, "UserEvents", opts, func(data []byte) error {
		var pb schema.UserEvent
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindUserEvents(opts db.Opts) (rows []*schema.UserEvent, err error) {
	err = j.ScanUserEvents(opts, func(data *schema.UserEvent) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ UserIdCol() int64 } = (*schema.UserEvent)(nil)

var _ interface{ CreatedTsCol() int64 } = (*schema.UserEvent)(nil)

var _ interface{ IndexCol() int64 } = (*schema.UserEvent)(nil)

func (j *Job) InsertUserEvent(pb *schema.UserEvent) error {
	return j.InsertUserEventRow(&UserEventRow{
		Data: pb,

		UserId: pb.UserIdCol(),

		CreatedTs: pb.CreatedTsCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) InsertUserEventRow(row *UserEventRow) error {
	var vals []interface{}

	vals = append(vals, row.UserId)

	vals = append(vals, row.CreatedTs)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "UserEvents", colsUserEvents, vals, j.adap)
}

var _ interface{ UserIdCol() int64 } = (*schema.UserEvent)(nil)

var _ interface{ CreatedTsCol() int64 } = (*schema.UserEvent)(nil)

var _ interface{ IndexCol() int64 } = (*schema.UserEvent)(nil)

func (j *Job) UpdateUserEvent(pb *schema.UserEvent) error {
	return j.UpdateUserEventRow(&UserEventRow{
		Data: pb,

		UserId: pb.UserIdCol(),

		CreatedTs: pb.CreatedTsCol(),

		Index: pb.IndexCol(),
	})
}

func (j *Job) UpdateUserEventRow(row *UserEventRow) error {
	key := KeyForUserEvent(row.Data)

	var vals []interface{}

	vals = append(vals, row.UserId)

	vals = append(vals, row.CreatedTs)

	vals = append(vals, row.Index)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "UserEvents", colsUserEvents, vals, key, j.adap)
}

func (j *Job) DeleteUserEvent(key UserEventsPrimary) error {
	return db.Delete(j.tx, "UserEvents", key, j.adap)
}

type CustomDataPrimary struct {
	KeyType *int64

	Key1 *int64

	Key2 *int64

	Key3 *int64

	Key4 *int64

	Key5 *int64
}

func (_ CustomDataPrimary) Unique() {}

var _ db.UniqueIdx = CustomDataPrimary{}

var colsCustomDataPrimary = []string{"key_type", "key1", "key2", "key3", "key4", "key5"}

func (idx CustomDataPrimary) Cols() []string {
	return colsCustomDataPrimary
}

func (idx CustomDataPrimary) Vals() (vals []interface{}) {
	var done bool

	if idx.KeyType != nil {
		if done {
			panic("Extra value KeyType")
		}
		vals = append(vals, *idx.KeyType)
	} else {
		done = true
	}

	if idx.Key1 != nil {
		if done {
			panic("Extra value Key1")
		}
		vals = append(vals, *idx.Key1)
	} else {
		done = true
	}

	if idx.Key2 != nil {
		if done {
			panic("Extra value Key2")
		}
		vals = append(vals, *idx.Key2)
	} else {
		done = true
	}

	if idx.Key3 != nil {
		if done {
			panic("Extra value Key3")
		}
		vals = append(vals, *idx.Key3)
	} else {
		done = true
	}

	if idx.Key4 != nil {
		if done {
			panic("Extra value Key4")
		}
		vals = append(vals, *idx.Key4)
	} else {
		done = true
	}

	if idx.Key5 != nil {
		if done {
			panic("Extra value Key5")
		}
		vals = append(vals, *idx.Key5)
	} else {
		done = true
	}

	return
}

func KeyForCustomData(pb *schema.CustomData) CustomDataPrimary {

	KeyType := pb.KeyTypeCol()

	Key1 := pb.Key1Col()

	Key2 := pb.Key2Col()

	Key3 := pb.Key3Col()

	Key4 := pb.Key4Col()

	Key5 := pb.Key5Col()

	return CustomDataPrimary{

		KeyType: &KeyType,

		Key1: &Key1,

		Key2: &Key2,

		Key3: &Key3,

		Key4: &Key4,

		Key5: &Key5,
	}
}

var colsCustomData = []string{"key_type", "key1", "key2", "key3", "key4", "key5", "data"}

func (j *Job) ScanCustomData(opts db.Opts, cb func(*schema.CustomData) error) error {
	return db.Scan(j.tx, "CustomData", opts, func(data []byte) error {
		var pb schema.CustomData
		if err := proto.Unmarshal(data, &pb); err != nil {
			return err
		}
		return cb(&pb)
	}, j.adap)
}

func (j *Job) FindCustomData(opts db.Opts) (rows []*schema.CustomData, err error) {
	err = j.ScanCustomData(opts, func(data *schema.CustomData) error {
		rows = append(rows, data)
		return nil
	})
	return
}

var _ interface{ KeyTypeCol() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key1Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key2Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key3Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key4Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key5Col() int64 } = (*schema.CustomData)(nil)

func (j *Job) InsertCustomData(pb *schema.CustomData) error {
	return j.InsertCustomDataRow(&CustomDataRow{
		Data: pb,

		KeyType: pb.KeyTypeCol(),

		Key1: pb.Key1Col(),

		Key2: pb.Key2Col(),

		Key3: pb.Key3Col(),

		Key4: pb.Key4Col(),

		Key5: pb.Key5Col(),
	})
}

func (j *Job) InsertCustomDataRow(row *CustomDataRow) error {
	var vals []interface{}

	vals = append(vals, row.KeyType)

	vals = append(vals, row.Key1)

	vals = append(vals, row.Key2)

	vals = append(vals, row.Key3)

	vals = append(vals, row.Key4)

	vals = append(vals, row.Key5)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Insert(j.tx, "CustomData", colsCustomData, vals, j.adap)
}

var _ interface{ KeyTypeCol() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key1Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key2Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key3Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key4Col() int64 } = (*schema.CustomData)(nil)

var _ interface{ Key5Col() int64 } = (*schema.CustomData)(nil)

func (j *Job) UpdateCustomData(pb *schema.CustomData) error {
	return j.UpdateCustomDataRow(&CustomDataRow{
		Data: pb,

		KeyType: pb.KeyTypeCol(),

		Key1: pb.Key1Col(),

		Key2: pb.Key2Col(),

		Key3: pb.Key3Col(),

		Key4: pb.Key4Col(),

		Key5: pb.Key5Col(),
	})
}

func (j *Job) UpdateCustomDataRow(row *CustomDataRow) error {
	key := KeyForCustomData(row.Data)

	var vals []interface{}

	vals = append(vals, row.KeyType)

	vals = append(vals, row.Key1)

	vals = append(vals, row.Key2)

	vals = append(vals, row.Key3)

	vals = append(vals, row.Key4)

	vals = append(vals, row.Key5)

	if val, err := proto.Marshal(row.Data); err != nil {
		return err
	} else {
		vals = append(vals, val)
	}

	return db.Update(j.tx, "CustomData", colsCustomData, vals, key, j.adap)
}

func (j *Job) DeleteCustomData(key CustomDataPrimary) error {
	return db.Delete(j.tx, "CustomData", key, j.adap)
}
